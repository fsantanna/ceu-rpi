native/pre do
    ##include "lua.h"
    ##include "lauxlib.h"
end

native do
    static void* l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) {
        (void)osize;  /* not used */
        tceu_app* _ceu_app = (tceu_app*) ud;
        void* ret = ceu_out_realloc(ptr, nsize);
        return ret;
     }
end

// TODO
native @pure _lua_newstate(), _lua_pushnumber(), _lua_tonumber();
native @nohold _ceu_out_log();

input (void)=>_lua_State* NEW do
    return _lua_newstate(_l_alloc, __ceu_app);
end

input (_lua_State* l, _lua_Number v)=>void PUSHNUMBER do
    _lua_pushnumber(l, v);
end

input (_lua_State* l, int index)=>int TONUMBER do
    return _lua_tonumber(l, index);
end

input (_lua_State* l, char* name)=>void GETGLOBAL do
    return _lua_getglobal(l, name);
end

input (_lua_State* l)=>void PUSHNIL do
    _lua_pushnil(l);
end

input (_lua_State* l, int index)=>int NEXT do
    return _lua_next(l, index);
end

input (_lua_State* l, int index, char* k)=>void GETFIELD do
    _lua_getfield(l, index, k);
end

input (_lua_State* l, int index)=>char* TOSTRING do
    return _lua_tostring(l, index);
end

input (_lua_State* l, char* str)=>int L_DOSTRING do
    _ceu_out_log(0, "\n");
    _ceu_out_log(0, "L_DOSTRING // ");
    _ceu_out_log(0, "L=");
    _ceu_out_log(1, l);
    _ceu_out_log(0, " str=");
    _ceu_out_log(1, str);
    _ceu_out_log(0, "\n");
    var int ret = _luaL_dostring(l, str);
    if ret then
        _ceu_out_log(0, "NO\n");
    else
        _ceu_out_log(0, "OK\n");
    end
end

_ceu_out_log(0, "lua started\n");
/*
_lua_pushnumber(l, 10);
var int v = _lua_tonumber(l, -1);

if v == 10 then
                #define GPFSEL1 ((uint*)0x20200004)
                #define GPSET0  ((uint*)0x2020001C)
                #define GPCLR0  ((uint*)0x20200028)
                var uint ra;
                ra = *GPFSEL1;
                ra = ra & ~(7<<18);
                ra = ra | 1<<18;
                *GPFSEL1 = ra;
                *GPCLR0 = 1<<16;   // GPIO16 on
end
*/

await FOREVER;
